version: "tdd_v0_to_gdd_v1"
generated_at: "2025-01-15T00:00:00Z"

source:
  old_tdd: "v0/tdd_orbitalrush_v0.md"
  target_gdd: "v1/gdd_orbitalrush_v1.md"
  delta_file: "agents/deltas/gdd_v0_to_v1.yaml"

# Gap analysis focuses on TDD completeness, not GDD changes.
# Delta analysis tracks GDD v0→v1 changes; gap analysis tracks TDD v0 gaps.
# Gaps are valuable when they identify implementation details, technical debt,
# or documentation structure issues that delta analysis doesn't cover.

gaps:
  - gap_id: "GAP-1-package-path-inconsistency"
    type: "OUTDATED"
    description: "TDD v0 Section 3 specifies package path /cmd/orbitalrush, but actual codebase uses /cmd/server. TDD should be updated to match implementation. This is technical debt - documentation doesn't match codebase."
    tdd_refs: ["§3 Server (Go) Design - Package Structure"]
    gdd_refs: []
    delta_relation: "NONE"
    implementation_spec: "Update TDD v0 Section 3 package structure diagram: change '/cmd/orbitalrush' to '/cmd/server' to match actual codebase structure. File location: server/cmd/server/main.go. Package name remains 'main'. Update all references to entrypoint path in documentation. This is a simple find-replace update in TDD v0 Section 3."
    priority: "MEDIUM"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-2-missing-room-code-algorithm"
    type: "MISSING"
    description: "TDD v0 doesn't specify room code generation algorithm. GDD v1 requires 6-character alphanumeric room codes, but TDD doesn't document how to generate them. Delta Δ-3-room-system mentions room codes exist but doesn't specify generation algorithm."
    tdd_refs: ["§3 Server (Go) Design"]
    gdd_refs: ["§3 Scope Included - Room System"]
    delta_relation: "Δ-3-room-system"
    implementation_spec: "Algorithm: Use crypto/rand.Reader to generate 6 characters from uppercase A-Z (26 chars) and digits 0-9 (10 chars) = 36 character set. Character set: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'. Generate random bytes, map to character set using modulo 36. Check collision against existing rooms map (roomCode -> Room), retry if collision (max 10 retries), return unique code. Store in room management system with mutex protection for concurrent access. Function signature: GenerateRoomCode(rooms map[string]*Room) (string, error)."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-3-missing-world-wraparound-formula"
    type: "MISSING"
    description: "TDD v0 doesn't specify world wraparound implementation placement and timing. While delta Δ-6-world-bounds-wraparound provides the formula, TDD doesn't specify WHERE in the game loop to apply wraparound (after integration, before collision detection) or that it applies to all ships in multiplayer context."
    tdd_refs: ["§3 Server (Go) Design - Physics", "§3 Server (Go) Design - Tick Loop"]
    gdd_refs: ["§6 Simulation Model - World Properties"]
    delta_relation: "Δ-6-world-bounds-wraparound"
    implementation_spec: "Algorithm: For each ship position after SemiImplicitEuler integration (in rules.Step, after Step 2 Physics), apply wraparound formula: pos.x = mod(pos.x + WORLD_WIDTH/2, WORLD_WIDTH) - WORLD_WIDTH/2, pos.y = mod(pos.y + WORLD_HEIGHT/2, WORLD_HEIGHT) - WORLD_HEIGHT/2. Apply before collision detection (Step 3). In multiplayer, apply to all ships in World.Ships array. Use math.Mod for modulo operation. Wraparound must be deterministic and applied consistently every tick."
    priority: "HIGH"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-4-missing-multiple-planet-gravity"
    type: "MISSING"
    description: "TDD v0 only specifies single sun gravity calculation. GDD v1 requires multiple planets (3-5) each with gravity wells. TDD doesn't specify how to sum gravity from multiple sources. Delta Δ-6-gravity-multiple-planets mentions multiple planets but doesn't specify gravity summation algorithm."
    tdd_refs: ["§3 Server (Go) Design - Physics"]
    gdd_refs: ["§6 Simulation Model - Gravity"]
    delta_relation: "Δ-6-gravity-multiple-planets"
    implementation_spec: "Algorithm: In rules.Step (Step 2 Physics), replace single GravityAcceleration(world.Ship.Pos, world.Sun.Pos, world.Sun.Mass, G, aMax) call with loop over world.Planets array. Initialize totalAcc = Vec2{0, 0}. For each planet in world.Planets, calculate: planetAcc = physics.GravityAcceleration(world.Ship.Pos, planet.Pos, planet.Mass, G, aMax). Sum: totalAcc = totalAcc.Add(planetAcc). Apply totalAcc to SemiImplicitEuler integration. Function signature: CalculateTotalGravity(shipPos Vec2, planets []Planet, G, aMax float64) Vec2. Each planet's gravity is calculated independently using inverse-square law, then vectors are summed (superposition principle)."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-5-missing-planet-generation-algorithm"
    type: "MISSING"
    description: "TDD v0 doesn't specify planet generation/distribution algorithm. GDD v1 requires 3-5 planets with varied sizes (30-80 m radius), masses (500-2000 units), and minimum spacing (200 m apart). Delta Δ-6-entity-planet mentions planet specifications but doesn't specify generation algorithm."
    tdd_refs: ["§3 Server (Go) Design"]
    gdd_refs: ["§6 Simulation Model - Entity Specifications - Planet"]
    delta_relation: "Δ-6-entity-planet"
    implementation_spec: "Algorithm: Function GeneratePlanets(count int, worldWidth, worldHeight float64) []Planet. For each planet: (1) Random radius using crypto/rand: radius = 30.0 + rand.Float64() * 50.0 (range [30, 80] m), (2) Random mass: mass = 500.0 + rand.Float64() * 1500.0 (range [500, 2000] game units), (3) Random position: posX = (rand.Float64() - 0.5) * worldWidth, posY = (rand.Float64() - 0.5) * worldHeight (bounds [-WORLD_WIDTH/2, WORLD_WIDTH/2] x [-WORLD_HEIGHT/2, WORLD_HEIGHT/2]), (4) Check minimum distance: for each existing planet, if distance(newPos, existingPos) < 200.0, retry position (max 50 retries per planet), (5) Check overlap: ensure distance >= newRadius + existingRadius (no overlap). Store in World.Planets []Planet array. Replace World.Sun with World.Planets in entity model."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-6-missing-camera-lerp-implementation"
    type: "MISSING"
    description: "TDD v0 doesn't specify camera lerp smoothing implementation. GDD v1 requires camera to smoothly follow player's ship with lerp factor ~0.1-0.15 per frame. Delta Δ-10-camera-follow mentions lerp factor but doesn't specify implementation details."
    tdd_refs: ["§4 Client (PixiJS) Design"]
    gdd_refs: ["§10 Camera System"]
    delta_relation: "Δ-10-camera-follow"
    implementation_spec: "Algorithm: Create Camera class with position Vec2, lerpFactor float (0.1-0.15, configurable). Each frame in render loop: (1) Get player ship position from state (myShipId from snapshot), (2) Calculate target: targetPos = ship.pos, (3) Apply lerp: cameraPos = cameraPos.Add(targetPos.Sub(cameraPos).Scale(lerpFactor)), (4) Clamp to world bounds: cameraPos.x = clamp(cameraPos.x, -WORLD_WIDTH/2 + viewportWidth/2, WORLD_WIDTH/2 - viewportWidth/2), same for y, (5) Apply camera transform to Pixi container: container.position.set(-cameraPos.x + screenWidth/2, -cameraPos.y + screenHeight/2). Camera does NOT wrap around (stays within bounds). Update before rendering sprites."
    priority: "HIGH"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-7-missing-radar-coordinate-mapping"
    type: "MISSING"
    description: "TDD v0 doesn't specify radar coordinate mapping algorithm. GDD v1 requires radar showing full world (2000 m × 2000 m) in fixed 200×200 px area, mapping world coordinates to radar pixels. Delta Δ-11-radar-system mentions coordinate mapping but doesn't specify formula."
    tdd_refs: ["§4 Client (PixiJS) Design"]
    gdd_refs: ["§11 Radar System"]
    delta_relation: "Δ-11-radar-system"
    implementation_spec: "Algorithm: Create Radar class with RADAR_WIDTH = 200, RADAR_HEIGHT = 200 (pixels), WORLD_WIDTH = 2000, WORLD_HEIGHT = 2000 (meters). Function worldToRadar(worldX, worldY float64) (radarX, radarY float64): radarX = ((worldX - (-WORLD_WIDTH/2)) / WORLD_WIDTH) * RADAR_WIDTH, radarY = ((worldY - (-WORLD_HEIGHT/2)) / WORLD_HEIGHT) * RADAR_HEIGHT. World bounds [-1000, 1000] x [-1000, 1000] map to [0, 200] x [0, 200] pixels. Render: (1) World bounds rectangle outline at (0, 0) size (200, 200), (2) Planets as circles: center = worldToRadar(planet.pos), radius = (planet.radius / WORLD_WIDTH) * RADAR_WIDTH, color by mass, (3) Ships as dots: pos = worldToRadar(ship.pos), color by player ID, size 2-3 px, (4) Own ship: different color/size (4-5 px), highlighted, (5) Pallets: pos = worldToRadar(pallet.pos), size 1-2 px, distinct color. Update every frame in render loop with latest snapshot data."
    priority: "HIGH"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-8-missing-room-session-pattern"
    type: "MISSING"
    description: "TDD v0 specifies 'one session per WebSocket connection' pattern, but GDD v1 requires 'one session per room' with multiple players per room. TDD doesn't specify room management pattern or how multiple connections share a session. Delta Δ-3-room-system mentions room system but doesn't specify session architecture."
    tdd_refs: ["§3 Server (Go) Design - Session Pattern", "§8 Design Patterns - Session Pattern"]
    gdd_refs: ["§3 Scope Included - Room System"]
    delta_relation: "Δ-3-room-system"
    implementation_spec: "Pattern: Create Room struct: type Room struct { roomCode string, players []*PlayerConnection, state RoomState (lobby|playing), hostPlayerID uint32, session *session.Session, mu sync.RWMutex }. PlayerConnection: { conn *transport.Connection, playerID uint32, name string }. Room manages one Session instance shared by all players. When player joins: room.mu.Lock(), room.players = append(room.players, newPlayer), room.mu.Unlock(). When host starts match (min 2 players): create shared session with World containing all player ships, start session.Run() in goroutine. Session processes inputs: each input message includes playerID, apply to corresponding ship in World.Ships[playerID]. Snapshot broadcasts: session.GetWorld() → convert to protocol → broadcast to all room.players[]. Pattern: one Session per Room (not per Connection). Use sync.RWMutex for concurrent room access (read lock for reads, write lock for player add/remove). Session tick loop runs once per room, processes all player inputs in single World state."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-9-missing-world-constants"
    type: "MISSING"
    description: "TDD v0 doesn't specify WORLD_WIDTH and WORLD_HEIGHT constant values. GDD v1 requires 2000 m × 2000 m world, but TDD only mentions 'world bounds may be defined as constants' without actual values. Delta Δ-3-larger-world mentions world size but doesn't specify constant definitions."
    tdd_refs: ["§3 Server (Go) Design - Physics", "§5 Configuration & Constants"]
    gdd_refs: ["§6 Simulation Model - World Properties"]
    delta_relation: "Δ-3-larger-world"
    implementation_spec: "Constants: In server/internal/sim/entities package: const WORLD_WIDTH float64 = 2000.0 (meters), const WORLD_HEIGHT float64 = 2000.0 (meters). Or in physics package if shared. Use for: (1) wraparound calculations (GAP-3), (2) world bounds checking (clamp camera, validate positions), (3) planet generation bounds (GAP-5), (4) radar coordinate mapping (GAP-7). World center at origin (0, 0), bounds from [-WORLD_WIDTH/2, WORLD_WIDTH/2] x [-WORLD_HEIGHT/2, WORLD_HEIGHT/2] = [-1000, 1000] x [-1000, 1000]. Export constants for use in other packages (physics, rules, client)."
    priority: "HIGH"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-10-missing-subsystem-spec-references"
    type: "MISSING"
    description: "TDD v0 Section 3 doesn't reference subsystem SPEC.md files. Codebase has SPEC.md files for entities, physics, rules, session, proto, transport, but TDD doesn't mention them. This is a documentation structure gap, not a feature gap."
    tdd_refs: ["§3 Server (Go) Design"]
    gdd_refs: []
    delta_relation: "NONE"
    implementation_spec: "Add subsection in TDD v0 Section 3 'Subsystem Specifications': Each subsystem has a SPEC.md file documenting its design, invariants, and ownership rules. Reference: (1) server/internal/sim/entities/SPEC.md - entity model (Ship, Sun/Planet, Pallet, World), (2) server/internal/sim/physics/SPEC.md - physics formulas (gravity, integration, collisions), (3) server/internal/sim/rules/SPEC.md - game rules (input, win/lose, step function), (4) server/internal/session/SPEC.md - session orchestration (tick loop, command queue), (5) server/internal/proto/SPEC.md - protocol types (Input, Snapshot messages), (6) server/internal/transport/SPEC.md - WebSocket transport (connection lifecycle, message routing). Update package structure section to note: 'Each package includes a SPEC.md file documenting its design and contracts.'"
    priority: "MEDIUM"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-11-missing-world-ships-array"
    type: "MISSING"
    description: "TDD v0 World entity has single Ship field (Ship Ship), but GDD v1 requires Ships array (Ships []Ship) for multiplayer support. Entity model needs to change from single ship to array of ships with player IDs. Delta Δ-8-networking-snapshot-format mentions ships array in protocol but doesn't specify entity model change."
    tdd_refs: ["§3 Server (Go) Design - Data Types"]
    gdd_refs: ["§7 Entities - Ship", "§8 Networking - Snapshot Format"]
    delta_relation: "Δ-8-networking-snapshot-format"
    implementation_spec: "Entity model changes: (1) Change World struct in entities/world.go: replace 'Ship Ship' field with 'Ships []Ship' field. (2) Add Ship.ID uint32 field to Ship struct in entities/ship.go: type Ship struct { ID uint32, Pos Vec2, Vel Vec2, Rot float64, Energy float32 }. (3) Update NewWorld() signature: NewWorld(ships []Ship, planets []Planet, pallets []Pallet) World. (4) Update rules.Step() signature: Step(world World, playerID uint32, input InputCommand, dt, G, aMax, pickupRadius float64) World. In Step(): find ship by ID: for i := range world.Ships { if world.Ships[i].ID == playerID { apply input to world.Ships[i] } }. (5) Update physics step: loop over all ships, calculate gravity for each ship (GAP-4), apply wraparound to each ship (GAP-3). (6) Update collision detection: check all ships for pallet pickups (loop over world.Ships), check all ships for planet collisions (loop over world.Ships and world.Planets). (7) Update win/lose conditions: per-player evaluation (each ship has its own Done/Win state, or World has per-player state map). (8) Update all code accessing world.Ship to use world.Ships array. (9) Update protocol conversion: convert world.Ships to snapshot.ships array."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"

  - gap_id: "GAP-12-missing-world-planets-array"
    type: "MISSING"
    description: "TDD v0 World entity has single Sun field (Sun Sun), but GDD v1 requires Planets array (Planets []Planet) for multiple planets. Entity model needs to change from single sun to array of planets. Delta Δ-7-entity-sun-to-planet mentions entity change but doesn't specify implementation details."
    tdd_refs: ["§3 Server (Go) Design - Data Types"]
    gdd_refs: ["§7 Entities - Planet", "§8 Networking - Snapshot Format"]
    delta_relation: "Δ-7-entity-sun-to-planet"
    implementation_spec: "Entity model changes: (1) Create Planet struct in entities/world.go (or entities/planet.go): type Planet struct { ID uint32, Pos Vec2, Radius float32, Mass float64 }. (2) Change World struct: replace 'Sun Sun' field with 'Planets []Planet' field. (3) Remove Sun type definition (or mark as deprecated). (4) Update NewWorld() signature: NewWorld(ships []Ship, planets []Planet, pallets []Pallet) World. (5) Update gravity calculation (GAP-4): in rules.Step(), loop over world.Planets array, sum gravity from all planets for each ship. (6) Update collision detection: in rules.Step(), for each ship, check collision with all planets: for each planet in world.Planets, if physics.ShipPlanetCollision(ship.Pos, planet.Pos, planet.Radius), trigger lose condition for that ship. (7) Update physics.ShipSunCollision() function: rename to ShipPlanetCollision() or create new function, takes planet.Pos and planet.Radius. (8) Update all code accessing world.Sun to use world.Planets array. (9) Update protocol conversion: convert world.Planets to snapshot.planets array. (10) Update initial world creation: use GeneratePlanets() from GAP-5 instead of single Sun."
    priority: "CRITICAL"
    status: "REVIEWED"
    arch_status: "UNRESOLVED"
